<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Weh.BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bigbigroot.online/"/>
  <updated>2020-03-24T09:27:50.511Z</updated>
  <id>https://bigbigroot.online/</id>
  
  <author>
    <name>bigbigroot</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Contiki OS 简介</title>
    <link href="https://bigbigroot.online/2019/10/19/Contiki-OS/"/>
    <id>https://bigbigroot.online/2019/10/19/Contiki-OS/</id>
    <published>2019-10-19T19:00:00.000Z</published>
    <updated>2020-03-24T09:27:50.511Z</updated>
    
    <content type="html"><![CDATA[<p>Contiki os 目前储存在<a href="https://github.com/contiki-ng/contiki-ng" target="_blank" rel="noopener">https://github.com/contiki-ng/contiki-ng</a> 上，适用于计算资源比较受限的计算机系统，其主要面向无线传感器网路节点。这个操作系统使用ProtoThread来实现多任务（之后会介绍），这种方式与使用线程来实现多任务相比天然具有更小的占用运行时的内存消耗的优势。在移植性上也几乎没有任何问题，甚至可以认为不需要移植（其实唯一影响移植的C编译器对标准C语法的支持）。</p><a id="more"></a><p>在任务调度方面，Contiki主要基于Protothread实现多任务。因此基于以上几点，如果设计的单片机程序，使用的单片机有足够的空间（1k以上的RAM和十几k的ROM），并且各个任务适合用事件驱动来组织的话，使用Contiki是很适合了。</p><h2 id="Protothread"><a href="#Protothread" class="headerlink" title="Protothread"></a>Protothread</h2><p>Protothread采用事件驱动的模型。事件的来源可以是中断或其他任务。Protothread之间共享运行栈，也就是说运行时栈占用的总的大小就是占用栈最大的任务的占用量。在内存特别受限的计算机系统中，这样保证实现多任务的同时也实现极低的内存占用。</p><p>以下是ProtoThread的一个接收数据的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pt.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span> <span class="title">pt</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">bool</span> is_io_completed</span><br><span class="line"></span><br><span class="line">PT_THREAD(recv(struct pt *pt))</span><br><span class="line">&#123;</span><br><span class="line">  PT_BEGIN(pt);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      PT_WAIT_UNTIL(pt,is_io_completed);</span><br><span class="line">      read_data();</span><br><span class="line">  &#125;</span><br><span class="line">  PT_END(pt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Protothread开始和结束时必须声明 <code>PT_BEGIN()</code> 和 <code>PT_END()</code> 这两个语句。<code>PT_WAIT_UNTIL()</code>会有条件的阻塞当前Protothread。当条件不满足时，当前的Protothread就会被阻塞，直到条件满足。这时候cpu就可以去执行其他的Protothread。由于Protothread没有独立的栈空间，在Protothread中声明的局部变量不能跨过 <code>PT_WAIT_UNTIL()</code> 使用。</p><h3 id="父子Protothread"><a href="#父子Protothread" class="headerlink" title="父子Protothread"></a>父子Protothread</h3><p>Protothread 可以使用 <code>PT_SPAWN()</code> 调用其他的Protothread，作为其子线程。同时，父线程被阻塞，直到子线程结束。</p><h3 id="Protothread-上下文切换的实现"><a href="#Protothread-上下文切换的实现" class="headerlink" title="Protothread 上下文切换的实现"></a>Protothread 上下文切换的实现</h3><p>Protothread由 <code>SET</code>和 <code>RESUME</code> 两个方法实现断点的保存和恢复。在Contiki中其实现包含在“os/sys/lc.h”文件下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">lc_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC_INIT(s) s = 0;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC_RESUME(s) switch(s) &#123; case 0:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC_SET(s) s = __LINE__; case __LINE__:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC_END(s) &#125;</span></span><br></pre></td></tr></table></figure><p><code>__LINE__</code>大部分ANSIC C编译器支持的c语言宏，其表示当前语句在文件中的行号。 当执行到<code>LC_SET</code>时，将行号被作为程序的离开时的位置。当CPU再次执行该Protothread时，<code>LC_RESUME</code> 将会被执行。<code>LC_RESUME</code>恢复到之前Protothread离开的位置开始执行。</p><h3 id="Protothread的实现"><a href="#Protothread的实现" class="headerlink" title="Protothread的实现"></a>Protothread的实现</h3><p>每一个Protothread的断点信息都保存在一个结构体中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span> &#123;</span></span><br><span class="line">  <span class="keyword">lc_t</span> lc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当程序运行到<code>PT_WAIT_UNTIL()</code> 时，CPU会将Protothread暂时停止执行，而行号会保存在pt中。因此<code>LC_SET</code> 包含在<code>PT_WAIT_UNTIL()</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_WAIT_UNTIL(pt, condition)        \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;\</span><br><span class="line">    LC_SET((pt)-&gt;lc);\</span><br><span class="line">    <span class="keyword">if</span>(!(condition)) &#123;\</span><br><span class="line">      <span class="keyword">return</span> PT_WAITING;\</span><br><span class="line">    &#125;\</span><br><span class="line">  &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>于此同时<code>PT_BEGIN()</code>会包含<code>LC_RESUME</code> :</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_BEGIN(pt) &#123; char PT_YIELD_FLAG = 1; <span class="meta-keyword">if</span> (PT_YIELD_FLAG) &#123;;&#125; LC_RESUME((pt)-&gt;lc)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_END(pt) LC_END((pt)-&gt;lc); PT_YIELD_FLAG = 0; \</span></span><br><span class="line">                   PT_INIT(pt); <span class="keyword">return</span> PT_ENDED; &#125;</span><br></pre></td></tr></table></figure><p>而我们最开始的示例程序，也可以转化为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pt.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span> <span class="title">pt</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">bool</span> is_io_completed</span><br><span class="line"></span><br><span class="line">PT_THREAD(recv(struct pt *pt))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span>(s) &#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">          pt-&gt;lc = <span class="number">11</span>; </span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">          <span class="keyword">if</span>(!(condition)) &#123;</span><br><span class="line">            <span class="keyword">return</span> PT_WAITING;</span><br><span class="line">          &#125;</span><br><span class="line">          read_data();</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此看出Protothread 上下文切换的方法有点类似于模拟了一种状态机。但如果使用GCC编译器，还可以使用GNU C 标准中的符号变量 （<code>__LABLE</code>）。</p><h3 id="Protothread使用的局限"><a href="#Protothread使用的局限" class="headerlink" title="Protothread使用的局限"></a>Protothread使用的局限</h3><p>Protothread共享栈空间的特征，也使其包含一下缺点：</p><ul><li>局部变量不能跨过阻塞函数使用。</li><li>在protothread中使用 switch-case结构语句（GCC编译器除外）。</li></ul><h2 id="Contiki中的任务调度"><a href="#Contiki中的任务调度" class="headerlink" title="Contiki中的任务调度"></a>Contiki中的任务调度</h2><p>Contiki中的任务基于Protothread，添加跟事件调度有关的信息。每一个任务包含一个结构体：</p><table><thead><tr><th align="left">process</th><th></th></tr></thead><tbody><tr><td align="left">next</td><td>指向下一个任务</td></tr><tr><td align="left">name</td><td>任务名称</td></tr><tr><td align="left">state</td><td>任务状态，初始值为PROCESS_STATE_NONE。</td></tr><tr><td align="left">needspoll</td><td>置位后，系统会优先执行该任务</td></tr><tr><td align="left">PT_THREAD</td><td>任务代码执行入口</td></tr><tr><td align="left">pt</td><td>Protothread的断点位置信息</td></tr></tbody></table><p><code>process_list</code>包含所有正在执行的进程。<code>process_start()</code>完成对进程的初始化并将进程添加到<code>process_list</code>。当<code>process_post()</code> 或<code>process_poll()</code> 执行后， 对应的被阻塞的进程会被标记。系统的主线程会不停的执行<code>process_run()</code>函数，需要被唤醒的进程将会被其调用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Contiki os 目前储存在&lt;a href=&quot;https://github.com/contiki-ng/contiki-ng&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/contiki-ng/contiki-ng&lt;/a&gt; 上，适用于计算资源比较受限的计算机系统，其主要面向无线传感器网路节点。这个操作系统使用ProtoThread来实现多任务（之后会介绍），这种方式与使用线程来实现多任务相比天然具有更小的占用运行时的内存消耗的优势。在移植性上也几乎没有任何问题，甚至可以认为不需要移植（其实唯一影响移植的C编译器对标准C语法的支持）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Operation System" scheme="https://bigbigroot.online/categories/Operation-System/"/>
    
      <category term="Contiki" scheme="https://bigbigroot.online/categories/Operation-System/Contiki/"/>
    
    
      <category term="IoT" scheme="https://bigbigroot.online/tags/IoT/"/>
    
      <category term="OS" scheme="https://bigbigroot.online/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>如何搭建个人博客</title>
    <link href="https://bigbigroot.online/2019/10/10/hello-world/"/>
    <id>https://bigbigroot.online/2019/10/10/hello-world/</id>
    <published>2019-10-10T10:59:50.552Z</published>
    <updated>2020-02-19T19:52:40.238Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直想要搭建一个博客系统，记录一下各种折腾的过程。一开始了解的是WorldPress，但之后的查找了相关的信息，还是锁定了<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>。Hexo是一个静态博客系统. (see <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> and <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>).</p><p>相比于WorldPress等博客系统，Hexo能提供更快的相应速度。</p><a id="more"></a><p>下面是一些Hexo的页面生成命令：</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="产生静态html文件"><a href="#产生静态html文件" class="headerlink" title="产生静态html文件"></a>产生静态html文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="部署到远端服务器"><a href="#部署到远端服务器" class="headerlink" title="部署到远端服务器"></a>部署到远端服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直想要搭建一个博客系统，记录一下各种折腾的过程。一开始了解的是WorldPress，但之后的查找了相关的信息，还是锁定了&lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;。Hexo是一个静态博客系统. (see &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; and &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;相比于WorldPress等博客系统，Hexo能提供更快的相应速度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Others" scheme="https://bigbigroot.online/categories/Others/"/>
    
    
      <category term="Hexo" scheme="https://bigbigroot.online/tags/Hexo/"/>
    
  </entry>
  
</feed>
